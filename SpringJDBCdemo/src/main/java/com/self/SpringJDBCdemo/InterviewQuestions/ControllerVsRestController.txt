‚úÖ Difference Between @Controller and @RestController
ANSWER:

@Controller
Used mainly for MVC / web applications
Returns:
View name (JSP / Thymeleaf)
Needs @ResponseBody annotation if you want JSON

Example:
@Controller
public class UserController {
   @ResponseBody
   @GetMapping("/user")
   public User getUser() {
       return new User();
   }
}


@RestController
Used for REST APIs
Automatically converts return object to JSON
No need for @ResponseBody annotation
Equivalent to:
@Controller
@ResponseBody


üî• What Happens Internally in @RestController?
1Ô∏è‚É£ Controller method returns an object
return new OrderResponseDTO();
2Ô∏è‚É£ Spring uses HttpMessageConverters
Jackson (JSON) is one of them and default used by Spring
Converts Java object ‚Üí JSON
3Ô∏è‚É£ Response is written to HttpServletResponse body
Content-Type: application/json
Status: 200 OK (default)
4Ô∏è‚É£ DispatcherServlet sends response back
Client receives JSON.
üîç Important Interview Detail
If Jackson is not present in classpath:
Spring cannot convert object ‚Üí JSON
You‚Äôll get HTTP 500 error
‚≠ê Quick Interview Summary Line (Memorize This)
"@RestController automatically serializes the return object to JSON using HttpMessageConverters like Jackson, whereas @Controller is used for view-based MVC."

<------------------------------------------------------------------------------------------------------------------>
‚úÖWhat is the difference between @RequestBody and @ModelAttribute?
@RequestBody is used for REST APIs to deserialize JSON payloads, while @ModelAttribute is used in MVC to bind form and request parameters to a model object.

@RequestBody
Reads raw HTTP request body
Uses HttpMessageConverters (Jackson)
Converts JSON ‚Üí Java object

Example:
@PostMapping("/users")
public UserDTO create(@RequestBody UserDTO dto) { }
Request:
{
  "name": "Nitesh",
  "email": "nitesh@gmail.com"
}
‚úî Used in REST APIs
‚úî JSON / XML payload
‚úî One-time deserialization


@ModelAttribute
Used mainly for MVC / web applications
View name (JSP / Thymeleaf)
Binds data from:
Form data
Query parameters
Path parameters
Uses Spring‚Äôs Data Binder
Field-by-field binding

Example:
@PostMapping("/register")
public String register(@ModelAttribute UserForm form) { }
Form submission:
name=Nitesh&email=nitesh@gmail.com
‚úî Used in MVC / form-based apps
‚úî Works even without JSON
‚úî Supports validation & default values

<------------------------------------------------------------------------------------------------------------------>
‚úÖWhat is the difference between PUT and PATCH?
PUT replaces the entire resource and is idempotent, whereas PATCH performs partial updates and is safer when only a few fields need to change.

PUT
Replaces the entire resource
Client sends full representation
Missing fields may be overwritten or null
Idempotent (calling it multiple times gives same result)
Example:
PUT /users/10
{
  "name": "Nitesh",
  "email": "nitesh@gmail.com",
  "age": 28
}
‚úî Used when client knows complete state
‚úî Common in internal APIs

If some fields are missing in the JSON request body:
No error is thrown
Missing fields are set to:
null for objects and 0 / false for primitives


PATCH
Updates only specific fields
Client sends partial data
Not guaranteed to be idempotent
Safer for partial updates
Example:
PATCH /users/10
{
  "email": "newmail@gmail.com"
}
‚úî Used when updating few fields only
‚úî Prevents accidental data loss


<------------------------------------------------------------------------------------------------------------------>
‚úÖWhat is idempotency?
 Give real API examples where idempotency matters.

ANSWER:
Idempotency means performing the same operation multiple times produces the same final state as performing it once.

This matters because retries, network failures, and duplicate events are normal in real systems.

PUT API (Idempotent)
PUT /users/10
{
  "email": "a@gmail.com"
}
Call once ‚Üí email = a@gmail.com
Call 10 times ‚Üí still a@gmail.com

‚≠ê 2. How to Implement Idempotency
Use an Idempotency Key
Client sends a unique key with each operation:
idempotency-key: 12345
Server stores:
request ‚Üí response mapping
If same key arrives again ‚Üí return stored result.
Used in: Stripe, Razorpay, PayPal