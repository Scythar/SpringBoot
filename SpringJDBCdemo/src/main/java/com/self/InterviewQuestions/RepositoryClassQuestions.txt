‚úÖWhat actually happens when you call CRUD APIs from Postman? Does connections open & closed everytime?

ANSWER:
Request 1 (POST from Postman)
HTTP request arrives
Spring starts a transaction (if @Transactional)
A DB connection is borrowed from the connection pool
SQL executes
Transaction commits / rolls back
Connection is returned to the pool (NOT closed)
Response sent
‚≠ê Connection is reused later

Request 2 (PUT from Postman)
New HTTP request
New transaction
A connection is borrowed again
Could be the same connection
Or another idle connection from pool
SQL executes
Transaction ends
Connection returned to pool

‚≠ê Why connection pooling is used
Opening a DB connection is:
Slow
Expensive
Non-scalable

So Spring Boot uses pooling to:
Reuse connections
Improve performance
Support concurrent users


<----------------------------------------------------------------------------------------------------------->
‚úÖ Difference between derived query, typed query and native query?

ANSWER:
Derived queries are auto-generated by Spring from method names, typed queries explicitly use JPQL with type safety, and native queries use raw SQL tied to the database.


1Ô∏è‚É£ Derived Query(JPQL)
public interface LocationRepository extends JpaRepository<Location, Long> {

    Optional<Location> findByCityAndAddress(String city, String address);

    int deleteLocationByCityAndAddress(String city, String address);
}

Key points:
No query written by you
Spring parses method name
Internally generates JPQL
Derived query methods (like findBy..., deleteBy...) are for: SELECT, DELETE

‚ùå They cannot perform UPDATE.


2Ô∏è‚É£ Typed Query (JPQL)
public interface LocationRepository extends JpaRepository<Location, Long> {

    @Query(
      "SELECT l FROM Location l WHERE l.city = :city AND l.address = :address"
    )
    Optional<Location> findLocationJPQL(
        @Param("city") String city,
        @Param("address") String address
    );
}
Key points:
Uses JPQL
Uses entity name (Location)
Uses entity fields
Return type is type-safe

3Ô∏è‚É£ Native Query (SQL)
public interface LocationRepository extends JpaRepository<Location, Long> {

    @Query(
      value = "SELECT * FROM VM_Location WHERE city = :city AND address = :address",
      nativeQuery = true
    )
    Location findLocationNative(
        @Param("city") String city,
        @Param("address") String address
    );
}
Key points:
Uses table name (VM_Location)
Uses column names
Database-specific SQL
No compile-time safety


üî• Side-by-Side Comparison (INTERVIEW GOLD)
Feature	                        Derived Query	        Typed Query (JPQL)      	Native Query
Query written by you	            ‚ùå No	                ‚úÖ Yes	                    ‚úÖ Yes
Language	                    Method name	                    JPQL	                    SQL
Operates on	                    Entity fields	                Entity fields	        Table columns
Type-safe	                        ‚úÖ Yes	                    ‚úÖ Yes	                    ‚ùå No
DB-independent	                    ‚úÖ Yes	                    ‚úÖ Yes	                    ‚ùå No
Most used	                        ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê	                ‚≠ê‚≠ê‚≠ê‚≠ê	                ‚≠ê‚≠ê


<----------------------------------------------------------------------------------------------------------->
‚úÖ What is persistence context?

ANSWER:
A Persistence Context is a runtime environment where JPA manages entity instances, tracks their state, and synchronizes changes with the database.
Persistence Context is a first-level cache and entity management space where JPA/Hibernate tracks and manages entity objects.

Who creates and manages it?
Created by EntityManager
In Spring:
One persistence context is usually created per transaction
Implemented internally by Hibernate

‚≠êWhy does Persistence Context exist?
1Ô∏è‚É£ Identity guarantee
User u1 = em.find(User.class, 1L);
User u2 = em.find(User.class, 1L);
‚úî u1 == u2 ‚Üí true
Same object returned ‚Äî no duplicate entities.

2Ô∏è‚É£ First-level cache
Database is hit only once
Subsequent finds come from memory

3Ô∏è‚É£ Dirty checking (VERY IMPORTANT)
User user = em.find(User.class, 1L);
user.setName("Nitesh");
‚úî No save() needed
‚úî Hibernate detects change automatically
‚úî SQL runs on flush/commit

4Ô∏è‚É£ Transaction synchronization
By default Changes are written to DB only when flushed
Improves performance and consistency

‚≠êEntity states (INTERVIEW FAVORITE)
State	        Meaning
Transient	    New object, not tracked
Managed	        Inside persistence context
Detached	    Exists but not tracked
Removed	        Marked for deletion

‚≠êRelation with save() and saveAndFlush()
 save() ‚Üí puts entity into Persistence Context
 saveAndFlush() ‚Üí puts entity + forces DB sync
 flush() ‚Üí sync persistence context ‚Üí database
 commit() ‚Üí flush + end transaction

‚≠êWhen is Persistence Context cleared?
 Transaction ends
 Explicit clear()
 Entity becomes detached
 Request completes (in Spring)


<------------------------------------------------------------------------------------------------------------->
‚úÖ What is the difference between save() and saveAndFlush() in Spring Data JPA?

ANSWER:
1Ô∏è‚É£ save()
repository.save(entity);
What it does
Persists or updates the entity in the Persistence Context
Does NOT immediately execute SQL
SQL is executed when:
The transaction commits, or
The persistence context is flushed automatically
Key points
Entity becomes managed
Changes are tracked (dirty checking)
Better for performance
Typical use
Normal CRUD operations
Inside @Transactional service methods

2Ô∏è‚É£ saveAndFlush()
repository.saveAndFlush(entity);
What it does
Persists/updates the entity
Immediately flushes the persistence context
Forces Hibernate to execute SQL right away

üî∫Key points
SQL (INSERT / UPDATE) runs immediately
Entity remains managed
Transaction is NOT committed yet

üî∫Why flushing matters
Flush = synchronize in-memory entity state with the database.

Hibernate delays flush for:
Better batching
Performance optimization
saveAndFlush() overrides that delay.

üî∫When to use which:
‚û°Ô∏èUse save() (MOST CASES)
Standard create/update logic
Let transaction manage flushing
Best performance

‚û°Ô∏èUse saveAndFlush() (ONLY WHEN NEEDED)
You need DB constraints checked immediately
Before running a native query
When subsequent logic depends on DB-written data
Debugging or legacy flows

‚ö†Ô∏è saveAndFlush() does not commit the transaction.
Rollback is still possible.


üî∫one example where saveAndFlush() is necessity.
You want to create a user and then immediately perform another operation that depends on the DB state, such as:
Executing a native query.

@Transactional
public void createUserAndAudit(User user) {

    // Step 1: Save user
    userRepository.saveAndFlush(user);  // save() will only update the user data to persistence context

    // Step 2: Run native query that depends on DB state
    auditRepository.insertAuditLog(user.getEmail());    //if user data is not update in DB, native query(insertAuditLog) will throw error.
}

Why saveAndFlush() is required here:
You need generated IDs immediately
A native query depends on that data
save() would only put the entity in Persistence Context
SQL INSERT might not execute yet
Native query runs before data exists in DB

üî• What does flush() really mean? (Interview Gold)
Flush = Hibernate generates SQL and sends it to DB
Commit = Transaction is permanently saved

Flush ‚ùå does not commit
Rollback is still possible after flush

