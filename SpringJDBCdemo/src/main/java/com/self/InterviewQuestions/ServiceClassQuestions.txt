‚≠ê Optimistic vs Pessimistic Locking (JPA / Hibernate)

ANSWER:
1Ô∏è‚É£ Optimistic Locking: Assumes conflicts are rare and checks for conflicts only at commit/update time.
No database lock while reading
Uses a version check
If data changed by another transaction ‚Üí fails(ROLLBACK)

Example:
@Entity
public class Product {

    @Id
    private Long id;

    private int quantity;

    @Version
    private int version;
}

Flow:
Tx A reads Product (version = 1)
Tx B reads Product (version = 1)
Tx A updates ‚Üí version becomes 2
Tx B tries to update ‚Üí ‚ùå OptimisticLockException


2Ô∏è‚É£ Pessimistic Locking: Assumes conflicts are common and locks data immediately.
Database lock acquired when reading
Other transactions wait or fail
Uses SQL locks

Example:
@Service
public class ProductService {

    @PersistenceContext
    private EntityManager entityManager;

    @Transactional
    public Product getProductForUpdate(Long id) {
        return entityManager.find(
            Product.class,
            id,
            LockModeType.PESSIMISTIC_WRITE
        );
    }

    @Transactional
    public void updateQuantity(Long id, int qty) {
        Product product = getProductForUpdate(id);
        product.setQuantity(qty);
    }
}


3Ô∏è‚É£ Side-by-Side Comparison (INTERVIEW GOLD)
Aspect	                    |    Optimistic	              |          Pessimistic
Locking                     |	No DB lock	              |              DB lock
When conflict detected	    |   At commit time	          |              At read time
Performance	                |      High	                  |          Lower
Blocking	                |     ‚ùå No	                  |          ‚úÖ Yes
Deadlock risk	            |    ‚ùå No	                  |          ‚úÖ Yes
Typical use	                |  Read-heavy apps	          |              Write-heavy apps
JPA support	                |   @Version	              |          LockModeType



4Ô∏è‚É£ When to use which?
‚úÖ Use Optimistic Locking when:
Conflicts are rare
High concurrency
REST APIs
Microservices
Most web applications

‚úÖ Use Pessimistic Locking when:
Conflicts are frequent
Financial transactions
Inventory updates
Seat booking systems

<------------------------------------------------------------------------------------------------------------->
‚úÖQUESTION:
When a method annotated with @Transactional executes, Spring starts a database transaction before the method begins. what does it mean?

ANSWER:
Assume you have:
@Transactional
public void updateUser() {
    userRepository.save(...);
}
Step-by-step explanation
1Ô∏è‚É£ Spring opens a DB transaction BEFORE the method body runs
Spring tells the database something like:
BEGIN TRANSACTION;
(or the equivalent depending on the DB vendor)
This means:
All SQL operations inside this method will now run inside one single atomic transaction.
They will not be permanently saved until Spring issues a COMMIT.
The important idea:
‚û°Ô∏è The moment control enters the method, a transaction context already exists.
2Ô∏è‚É£ All repository calls inside the method participate in THIS transaction
Example:
userRepo.save(user);   // part of the same transaction
orderRepo.save(order); // same transaction
If any of these fail ‚Üí everything rolls back.
3Ô∏è‚É£ After the method completes, Spring decides:
‚úî If no exception ‚Üí Spring sends COMMIT
DB now permanently saves:
COMMIT;
‚ùå If an exception occurs ‚Üí Spring sends ROLLBACK
DB discards all SQL operations:
ROLLBACK;
üîç Why does Spring need to start the transaction before entering the method?
Because:
If you run multiple SQL updates, they must belong to the same atomic block.
You cannot start/commit a transaction after some SQL has already executed.
Spring must prepare the transactional context for the entire method.
üß† Example timeline
With @Transactional:
[Spring] BEGIN
   ‚Üì
execute method
   ‚Üì
[Spring] COMMIT or ROLLBACK
Without @Transactional:
Every SQL executes independently:
SQL1 committed immediately
SQL2 committed immediately
SQL3 committed immediately
If SQL3 fails ‚Üí SQL1 and SQL2 are already saved ‚Üí ‚ùå inconsistent state.

Generally @Transactional annotation is used only for DB update query methods in service class.

<--------------------------------------------------------------------------------------------------------------------->
QUESTION:
what happens if a method inside a transactional class is marked as @Transactional(propagation = Propagation.REQUIRES_NEW)

ANSWER:
‚úÖ What does REQUIRES_NEW mean?
When a method is annotated with REQUIRES_NEW, Spring:
Suspends the currently running transaction (if any)
Starts a brand-new independent transaction
When the method finishes ‚Üí commits or rolls back independently
Then resumes the original transaction
‚úÖ Where is it useful?
Logging events that must be saved even if main transaction fails
Sending emails / audit logs
Saving partial progress
Retrying operations
Compensating transactions
‚≠ê Complete Example
Imagine an order placement process:
‚ñ∂ Main flow (big transaction)
Save order
Deduct inventory
Charge payment
‚ñ∂ But you always want to save an audit log
EVEN IF order creation fails.
üìå Java Code Example
@Service
public class OrderService {
    @Autowired
    private PaymentService paymentService;
    @Autowired
    private AuditService auditService;
    @Transactional
    public void placeOrder(Order order) {
        // MAIN TRANSACTION STARTS
        // Step 1: save the order
        saveOrder(order);
        // Step 2: try payment
        try {
            paymentService.chargeCustomer(order);
        } catch (Exception e) {
            // Payment failed ‚Üí order fails
            // BUT AUDIT LOG MUST STILL BE SAVED
            auditService.saveAuditLog("Payment failed for order " + order.getId());
            throw e;
        }
        // Step 3: successful
        auditService.saveAuditLog("Order placed successfully: " + order.getId());
        // MAIN TRANSACTION COMMITS (unless an exception)
    }
}
üìå Audit Service with REQUIRES_NEW
@Service
public class AuditService {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveAuditLog(String message) {
        AuditLog log = new AuditLog();
        log.setMessage(message);
        log.setTimestamp(LocalDateTime.now());
        // SAVE in a NEW TRANSACTION
        auditLogRepository.save(log);
    }
}
‚≠ê What happens step-by-step?
Case 1 ‚Üí PAYMENT FAILS
Part	Transaction	Result
placeOrder()	T1	Rolls back
saveAuditLog()	T2 (NEW)	Commits successfully
‚û° Audit success message is saved even though order failed.
Case 2 ‚Üí ORDER SUCCESS
Both logs:
"Order placed successfully‚Ä¶" ‚Üí committed in T2
Entire order logic ‚Üí committed in T1
üî• Visual Transaction Flow
placeOrder() -- starts Transaction T1
    |
    |-- chargeCustomer() --> fails
    |
    |-- saveAuditLog() -- starts Transaction T2
    |        |
    |        |-- T2 commits independently
    |
T1 rolls back

Note: if T2 fails, does not mean T1 will also rollback. and if T1 fails, T1 is paused and