✅ In a real production-grade Spring Boot app, how do you structure your project packages and why?
ANSWER:
A good Spring Boot project follows layered architecture:
1. controller/
Handles HTTP/API layer
Maps endpoints
Validates request DTOs
Calls services
Returns responses
➡ Reason: Keeps API responsibilities isolated.

2. service/
Contains business logic
Implements use cases
Coordinates repository calls
Handles transactions (via @Transactional)
➡ Reason: Keeps logic independent from persistence → easier to test & maintain.

3. repository/
Deals with DB operations
Uses Spring Data JPA
Contains JPQL/Native queries when required
➡ Reason: Data access is separate → replaceable (JPA → Mongo → JDBC) without touching service.

4. entity/
JPA entities mapped to DB tables
Contains relationships, constraints
➡ Reason: Centralizes DB mapping.

5. dto/
Used for request/response models
Hide internal entity fields
Prevent over-posting issues
Useful for security and versioning
➡ Reason: Clean separation between API layer and DB layer.

6. config/
Contains beans, security config, swagger config, etc.
➡ Reason: All runtime configuration stays in one place.

7. exception/
Global exception handlers (e.g., @ControllerAdvice)
➡ Reason: Centralized error handling used in real production apps.

8. security/
JWT filters, auth providers, custom user details, etc.
➡ Reason: Security layer should be isolated completely.

9. util/
Helpers, validators, utility classes.
➡ Reason: Reduce duplication and keep business logic clean.

⭐ Why is this structure testable & scalable?
Testable:
Each layer is independent → controller tests mock service, service tests mock repositories.
Loose coupling = easy unit tests
Scalable:
New features drop naturally into existing folders
Can replace any layer without rewriting the whole app
Good for microservices growth

<---------------------------------------------------------------------------------------------------------->
⭐ What is the difference between Spring and SpringBoot?
ANSWER:
Spring is a massive ecosystem designed to simplify Java enterprise development. Its core philosophy is Dependency Injection (DI) and Inversion of Control (IoC).
Manual Configuration: In a traditional Spring project, you have to manually configure almost everything—DataSources, Transaction Managers, View Resolvers—using either XML or Java @Configuration classes.
Deployment: You typically need to set up and manage an external web server like Apache Tomcat or Glassfish to deploy your WAR file.
Boilerplate Code: You need to write a lot of repetitive setup code before you can even run a "Hello World" application.


Spring Boot (The Productivity Tool)
Spring Boot is a module built on top of the Spring Framework. It doesn't replace Spring; it manages it for you.
Auto-Configuration: This is the "magic" of Spring Boot. It looks at the dependencies on your classpath. If it sees spring-boot-starter-web, it automatically assumes you are building a web app and configures Tomcat and Spring MVC for you.

<-------------------------------------------------------------------------------------------------------------->
⭐ How traditional Spring handled the dependency injection?

ANSWER:
1️⃣in traditional Spring dependency was configured manually in applicationContext.xml file

<beans>

    <bean id="userRepository" class="com.app.UserRepository" />

    <bean id="userService" class="com.app.UserService">
        <property name="repository" ref="userRepository"/>
    </bean>

    <bean id="userController" class="com.app.UserController">
        <property name="service" ref="userService"/>
    </bean>

</beans>

2️⃣and then initialization of that bean into another class worked like below example.

public class UserRepository {
    public String findUser() {
        return "User from DB";
    }
}
public class UserService {
    private UserRepository repository;

    public void setRepository(UserRepository repository) {
        this.repository = repository;
    }

    public String getUser() {
        return repository.findUser();
    }
}

3️⃣ Or using JAVA configuration class : create a class and annotate it using @Configuration and then declare the bean inside it.

@Configuration
public class AppConfig {

    @Bean
    public UserRepository userRepository() {
        return new UserRepository();
    }

    @Bean
    public UserService userService() {
        return new UserService(userRepository());
    }

    @Bean
    public UserController userController() {
        return new UserController(userService());
    }
}



