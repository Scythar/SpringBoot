Question:
Which design patterns have you applied most often in your projects and why? Expected:
Singleton, Factory, Builder, Observer, Strategyâ€” with practical examples.

ANSWER:
/*
========================================================
DESIGN PATTERNS USED IN MICROSERVICES (JAVA + SPRING BOOT)
========================================================
*/

/*
--------------------------------------------------------
1. SINGLETON PATTERN
--------------------------------------------------------
Usage:
- When only ONE instance of a class should exist
- Used for shared business logic and configuration

Real-world usage:
- @Service
- @Repository
- @Component
(Spring beans are Singleton by default)


--------------------------------------------------------
2. FACTORY PATTERN
ðŸ‘‰ Decides WHICH object to create at runtime
--------------------------------------------------------
Usage:
- When object creation depends on input or condition
- Avoids scattered if-else logic

Real-world usage:
- Payment service selection
- Notification service selection
- file parser excel/csv/json
- Multiple authentication mechanisms JWT / OAuth / SAML
- Logging Framework Selection Log4j / Logback / Splunk


--------------------------------------------------------
3. STRATEGY PATTERN
ðŸ‘‰ Decides WHICH algorithm/behavior/business logic to execute at runtime
--------------------------------------------------------
Usage:
- When multiple algorithms/business rules exist
- Logic can change at runtime

Real-world usage:
- Discount calculation - Normal price, Festival discount, Employee discount, Coupon-based discount
- Authentication & Authorization - JWT / OAuth / SAML / API key authentication
- Payment Routing Logic - fastest / cheapest / reliable
*/

// Strategy interface
public interface DiscountStrategy {
    double applyDiscount(double amount);
}

// Strategy 1
@Component
public class FestivalDiscountStrategy implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount * 0.9;
    }
}

// Strategy 2
@Component
public class NoDiscountStrategy implements DiscountStrategy {
    public double applyDiscount(double amount) {
        return amount;
    }
}

// Context class
@Service
public class PricingService {

    private final DiscountStrategy discountStrategy;

    public PricingService(DiscountStrategy discountStrategy) {
        this.discountStrategy = discountStrategy;
    }

    public double calculateFinalPrice(double amount) {
        return discountStrategy.applyDiscount(amount);
    }
}


/*
--------------------------------------------------------
4. BUILDER PATTERN
--------------------------------------------------------
Usage:
- When object has many fields
- Avoids constructor overloading
- Supports immutability

Real-world usage:
- API response DTOs
- Request objects
*/

public class OrderResponse {

    private String orderId;
    private String status;
    private double amount;

    private OrderResponse(Builder builder) {
        this.orderId = builder.orderId;
        this.status = builder.status;
        this.amount = builder.amount;
    }

    public static class Builder {

        private String orderId;
        private String status;
        private double amount;

        public Builder orderId(String orderId) {
            this.orderId = orderId;
            return this;
        }

        public Builder status(String status) {
            this.status = status;
            return this;
        }

        public Builder amount(double amount) {
            this.amount = amount;
            return this;
        }

        public OrderResponse build() {
            return new OrderResponse(this);
        }
    }
}

// Usage
OrderResponse response = new OrderResponse.Builder()
        .orderId("ORD123")
        .status("SUCCESS")
        .amount(1000)
        .build();


/*
--------------------------------------------------------
5. OBSERVER PATTERN
--------------------------------------------------------
Usage:
- One event triggers multiple actions
- Loose coupling between components

Real-world usage:
- Kafka events
- Email / SMS notifications
- Audit logging
*/

// Event class
public class OrderCreatedEvent {

    private final String orderId;

    public OrderCreatedEvent(String orderId) {
        this.orderId = orderId;
    }

    public String getOrderId() {
        return orderId;
    }
}


// Event publisher
@Service
public class OrderService {

    private final ApplicationEventPublisher publisher;

    public OrderService(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void createOrder(String orderId) {
        publisher.publishEvent(new OrderCreatedEvent(orderId));
    }
}


// Event listener
@Component
public class NotificationListener {

    @EventListener
    public void onOrderCreated(OrderCreatedEvent event) {
        System.out.println("Sending notification for order " + event.getOrderId());
    }
}


/*
--------------------------------------------------------
REAL-WORLD MICROSERVICE SUMMARY
--------------------------------------------------------
One microservice commonly uses multiple design patterns:
- Singleton â†’ Service & Repository beans
- Factory â†’ Object creation logic
- Strategy â†’ Business rule variations
- Builder â†’ DTO construction
- Observer â†’ Event-driven workflows
This is standard practice in real-world production systems.
*/
